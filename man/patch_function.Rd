% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch_function.R
\name{patch_function}
\alias{patch_function}
\title{Patch a function in current R Session}
\usage{
patch_function(
  f,
  search_str,
  expr,
  line_location,
  replace_it = FALSE,
  append_after = TRUE,
  move_up_to = NULL,
  chop_locator_to = NULL,
  further_locator = integer(0),
  new_arguments = NULL,
  env = NULL,
  auto_assign_patched_function = FALSE,
  no_store = FALSE
)
}
\arguments{
\item{f}{Function to modify / patch}

\item{search_str}{String (or strings; in case multiple strings is given only
first match will be considered. Even for multiple matches of single
supplied string \strong{only first match} will be considered.) to find in the
function body which should act as location of modification.}

\item{expr}{Expression or code to punch in}

\item{line_location}{Exact line location (a vector similar to return of
\code{\link[=locate_section]{locate_section}}. Note this function \code{locate_section}
is available only in \strong{dynamic attachment}). This is ignored if
\code{search_str} is present.}

\item{replace_it}{Whether replace it (the match by \code{search_str}) (if \code{TRUE}
the argument \code{append_after} will be omitted)}

\item{append_after}{Whether add after it (\code{replace_it} should be \code{FALSE})}

\item{move_up_to}{Fine-tuning the locator (should be an index within the
length of locator). Moving up from found match.}

\item{chop_locator_to}{Fine-tuning the locator (should be an index within the
length of locator). Moving from beginning of found match. \code{move_up_to} is
better option. It is exactly opposite of \code{move_up_to} (in a sense).}

\item{further_locator}{(Optional) In case you need to further tune \emph{locator}
by adding few extra locations (or depth) after found match (by
\code{search_str}) or supplied location (by \code{line_location}). A vector of
integers (specifying location in nested list form of function body).
\code{further_locator} is applied before fine tuning by other arguments
(\code{move_up_to} and \code{chop_locator_to}).}

\item{new_arguments}{(Optional) In case one need to change the arguments of
the function. Note that it has to be full list of argument. (It should not
be considered as additional argument). You can use \code{\link[base:list]{alist}}
for this (\emph{Remember to give \code{=} otherwise it will not work}). Leave it to
\code{NULL} (default) in case argument alteration is not required.}

\item{env}{In case \code{expr} is passed from a different location apart from
global environment. It may be required if \code{patch_function} is called inside
a function or in different environment from \code{.GlobalEnv}}

\item{auto_assign_patched_function}{Whether the patched function to be auto
patched into it's source. By default \code{FALSE}. Usethis with care.}

\item{no_store}{If set to \code{TRUE}. It will not try to backup the function in
current session. (Maybe useful for understanding edit locations before
actual patch work.)}
}
\value{
Patched \code{function} (if the \code{search_str} is found)
}
\description{
Any function can be modified programmatically within a session.
It also keeps a backup of original function which can be retried by calling
\code{patch_function} and \code{f} argument only (without specifying anything else).
}
\details{
Backup of the original function is kept in an environment for
restoration purpose (if required). That can be obtained by calling
\code{patch_function} and \code{f} argument only (without specifying anything else).

Note that a function can be patched unlimited times (backup of original
function, as available in single session of the package, will be kept only
once)

In case there is a high chance that the target function \code{f} will undergo
several modifications, then \code{search_str} should be given in a way that
match happens even if the code changes (to certain degree). The first match
will be considered for locating purposes.

It is sometimes difficult to understand how \code{move_up_to} or
\code{chop_locator_to} should be constructed. In such cases, users may attach
optional functions to help them understand the locator. Which can be done
via simple \code{patch_function()} call. Meaning omitting all arguments. It is
referred as \strong{dynamic attachment}.

Note that few sample use-cases are supplied with the package. This may be
accessed by

\emph{\code{source(system.file("embedded","usecases.R",package = "patch"))}}

However, note that these may cause problem (though it is meant for R-Studio
actually) with R-Studio. If such things happen kindly restart the session.
This feature is not checked as a part of package evaluations. So \strong{use it
at your own risk}.
}
\section{Types of \emph{patching}}{


\code{{patch}} is designed for quick in-session modification to certain type of
functions. Sometimes it is useful if some experimental feature (or yet to
implement feature) is required quickly.

There are many ways you can patch a function. But most importantly there is
a concept of robust patching. The underlying source of the target function
changes as and when developer releases new version, patches etc. The idea
is to generate a robust \emph{(so that the patch will mostly work even if there
is a code change in the function)} patch.
\subsection{Robust way:}{

Ideally one should use a \code{search_str} and possibly \code{move_up_to} to fine
tune the patch. Make sure \code{search_str} is a core item (part of the body of
target function) which usually will not change (unless there is major
changes in the underlying code-base) One can use \strong{dynamic attachment} to
fine tune the \code{move_up_to} numbers (or directly \code{patch_function}).
}
}

\examples{

# test function
ftest <- function(x, y){
  u <- x+y
  v <- u^2
  z <- v+x
  if(x\%\%2==0){
    z0 <- z+1
  }else{
    if(y\%\%2 == 0){
      v <- 11
      z1 <- 14
      u <- 10
    }else{
      z1 <- 10
    }
    z0 <- z^2+z1
  }

  if(z0\%\%5 == 1){
    z2 <- z0*2
  }else{
    z2 <- z0*3
  }

  z2

}


# find z1 <- 14 and add z1 <- z1 + length(letters) after that
patch_function(ftest, "z1 <- 14", z1 <- z1 + length(letters))

# multiple candidate for matching locator (first match will be considered)
patch_function(ftest, c("v <- 11","z1 <- 14","u <- 10"),
z1 <- z1 + length(letters), replace_it = TRUE)
}
